A compiler translates source programs into assembly code[![Define this term](https://www.cs.fsu.edu/~engelen/courses/COP402003/define.gif)](https://www.cs.fsu.edu/~engelen/courses/COP402003/board.html#assembly), machine code, or code for a [[virtual machine]][![Define this term](https://www.cs.fsu.edu/~engelen/courses/COP402003/define.gif)](https://www.cs.fsu.edu/~engelen/courses/COP402003/board.html#virtualmachine).

## Compilation
-   Compilation of a program proceeds through a series of _phases_, where subsequent phases use information found in an earlier phase or uses a form of the program produced by an earlier phase
- Each phase may consist of a number of _passes_ over the program representation

![[Pasted image 20221125105651.png]]

### Compiler phases
-   Lexical analysis
-   Syntax analysis
-   Semantic analysis
-   Code generation

## Lexical Analysis
- Lexical Analysis breaks up a program into a stream of [[Tokens]]
- This is also known as *scanning* performed by a [[Scanner]]
- A *lexical error* is produced when an unrecognized charecter is encountered

## Context-Free Grammars
- A *context free grammar* defines the *syntax* of a programming language
- The grammar defines *syntactic categories*
	- Statements
	- Expressions
	- Declarations
- Categories are subdivided into more detailed categories
	- Loop-statement
	- If-statement
	- Logical-expression
	- ...
- Some programming language manuals include language grammars

## Syntax Analysis
- Parsing organizes tokens into a hierarchy called a *[[Parse Tree]]*
- A grammar of a language with the token stream defines the structure of the parse tree
- A *syntax error* is produced by a compiler when the parse tree cannot be constructed for a program (fragment)

## Semantic Analysis
- Semantic analysis is appiled by a compiler to discover the meaning of a program by analyszing its [[Parse Tree]] or [[Abstract syntax tree (AST)]]
- *[[Static semantic checks]]* are performed at compile time
	- Type checking
	- Every variable is declared before used
	- Identifiers are used in appropriate contexts
	- Check subroutine call arguments
	- Check labels
- [[Dynamic semantic checks]] are performed at run time, and the compiler produces code that performs these checks
	- Array subscript values are within bounds
	- Arithmetic errors, e.g. division by zero
	- Pointers are not dereferenced unless pointing to valid object
	- A variable is used but hasn't been initialized
	- When a check fails at run time, an exception is raised

## Strong Typing
- A language is strongly typed "*if (type) errors are always detected*"
- Such errors are listed on previous slide
- Errors are either detected at compile time or at run time
- Strong typing makes language sage and easier to use, but slower because of dynamic semantic checks

## Intermediate Code Generation
- A typical intermediate form of code produced by the semantic analyzer is an [[Abstract syntax tree (AST)]]
- The AST is *annotated* with useful information such as pointers to the [[Symbol table]] entry of identifiers
- Example AST for the gcd Pascal Program
![[Pasted image 20221125110958.png]]

## Target Code Generation and Optimization
- The AST with the annotated information is traversed by the compiler to generate a low-level intermediate form of code, close to assembly
- This *machine-independant* intermediate form is optimized
- From the machine independant form assembly or object code is generated by the compiler
- This *machine-specfici code* is optimized to exploit specific hardware features