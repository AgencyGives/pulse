A **metaobject protocol** (MOP) provides the vocabulary ([protocol](https://en.wikipedia.org/wiki/Protocol_(object-oriented_programming) "Protocol (object-oriented programming)")) to access and manipulate the structure and behaviour of systems of objects. Typical functions of a metaobject protocol include:[[2]](https://en.wikipedia.org/wiki/Metaobject#cite_note-2)

-   Create or delete a new class
-   Create a new property or method
-   Cause a class to inherit from a different class ("change the class structure")
-   Generate or change the code defining the methods of a class

Metaobject protocol is contrary to [Bertrand Meyer](https://en.wikipedia.org/wiki/Bertrand_Meyer "Bertrand Meyer")'s [open/closed principle](https://en.wikipedia.org/wiki/Open/closed_principle "Open/closed principle"), which holds that software object systems should be _open for extension_ but _closed for modification_. This principle effectively draws a distinction between _extending_ an object by adding to it, and _modifying_ an object by redefining it, proposing that the former is a desirable quality ("_objects should be extensible to meet the requirements of future use cases_"), while the latter is undesirable ("_objects should provide a stable interface not subject to summary revision_"). Metaobject protocol, by contrast, transparently exposes the internal composition of objects and the entire object system in terms of the system itself. In practice, this means that programmers may use objects to redefine themselves, possibly in quite complex ways.

Furthermore, metaobject protocol is not merely an [interface](https://en.wikipedia.org/wiki/Application_Programming_Interface "Application Programming Interface") to an "underlying" implementation; rather, through metaobject protocol the object system is [recursively implemented](https://en.wikipedia.org/wiki/Recursive_definition "Recursive definition") in terms of a _meta_-object system, which itself is theoretically implemented in terms of a _meta_-metaobject system, and so on until an arbitrary [base case](https://en.wikipedia.org/wiki/Base_case_(recursion) "Base case (recursion)") (a consistent [state](https://en.wikipedia.org/wiki/State_(computing) "State (computing)") of the object system) is determined, with the protocol as such being the recursive functional relationship between these implementation levels.

Implementing object systems in such a way opens the possibility for radical discretionary redesign, providing deep flexibility but introducing possibly complex or difficult-to-understand metastability issues (for instance, the object system must not [destructively update](https://en.wikipedia.org/wiki/Persistent_data_structure "Persistent data structure") its own metaobject protocol - its internal self-representation - but the potential destructiveness of some updates is non-trivial to predict and may be hard to reason about), depending on the recursive depth to which the desired modifications are propagated.[[3]](https://en.wikipedia.org/wiki/Metaobject#cite_note-AMOP_text-3) For this reason, metaobject protocol, when present in a language, is usually used sparingly and for specialised purposes such as software that transforms other software or itself in sophisticated ways, for example in reverse engineering.[[4]](https://en.wikipedia.org/wiki/Metaobject#cite_note-4)